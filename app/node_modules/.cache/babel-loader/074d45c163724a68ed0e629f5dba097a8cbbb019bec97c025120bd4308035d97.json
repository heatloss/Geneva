{"ast":null,"code":"import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\nconst theme = `:root{--st-border-color:#636e72;--st-btn-secondary-color:#7977e1;--st-btn-secondary-color-hover:#ffffff;--st-btn-secondary-bg:#000000;--st-btn-secondary-bg-hover:#9a99e8;--st-btn-secondary-bg-active:#7977e1;--st-btn-gray-color:#f5f7f8;--st-btn-gray-color-hover:#ffffff;--st-btn-gray-bg:transparent;--st-btn-gray-bg-hover:#b2bec3;--st-btn-gray-bg-active:#636e72;--st-btn-asphalt-color:#f5f7f8;--st-btn-asphalt-bg:transparent;--st-btn-asphalt-bg-hover:#2d3436;--st-btn-asphalt-bg-active:#1e2224;--st-page-bg:#000000;--st-content-bg:#1e2224;--st-content-bg-hover:#343382;--st-content-bg-active:#232257;--st-text-color-ink:#f5f7f8;--st-text-color-blurple:#9a99e8;--st-text-color-asphalt:#f5f7f8;--st-text-color-lava:#ef8e7d;--st-text-color-emerald:#97e28f;--st-text-color-white:#000000;--st-text-color:#f5f7f8;--st-text-color-support:#f5f7f8;--st-text-color-accent:#9a99e8;--st-nav-color:#ffffff;--st-nav-color-hover:#bcbbf0;--st-nav-bg:#ffffff;--st-nav-bg-hover:#343382;--st-nav-bg-active:#232257;--st-alert-warning-color:#fef3d9;--st-alert-warning-color-inverse:#957628;--st-alert-blurple-color:#ddddf7;--st-alert-blurple-color-inverse:#343382;--st-alert-gray-color:#dfe6e9;--st-alert-gray-color-inverse:#2d3436;--st-alert-error-color:#fad9d4;--st-alert-error-color-inverse:#892817;--st-alert-success-color:#dcf5da;--st-alert-success-color-inverse:#317c29;--st-token-blurple-color:#ddddf7;--st-token-blurple-bg:#5755d9;--st-token-gray-color:#dfe6e9;--st-token-gray-bg:#636e72;--st-token-rose-color:#33111d;--st-token-rose-bg:#ff77a8;--st-token-lava-color:#2e0d08;--st-token-lava-bg:#e96851;--st-token-tangerine-color:#311d0e;--st-token-tangerine-bg:#f8a66c;--st-token-sunshine-color:#32270d;--st-token-sunshine-bg:#f9d069;--st-token-emerald-color:#10290e;--st-token-emerald-bg:#97e28f;--st-token-ice-color:#0d2a33;--st-token-ice-bg:#40d0ff;--st-input-bg:#000000;--st-input-bg-disabled:#2d3436;--st-input-bg-error:#2e0d08;--st-input-handle-color:#ddddf7;--st-input-track-color:#000000;--st-input-track-color-error:#2e0d08;--st-input-icon-color:#636e72;}`;\nvar modeDark = theme;\n\n// default localstorage ID\nconst STORAGE_ID_DEFAULT = 'st-mode';\nconst modeStyles = {\n  light: '',\n  dark: modeDark\n};\nconst modeRegex = /^st-mode--[a-zA-Z]*$/;\n\n/**\n * Detects the system color mode by reading prefers-color-scheme\n * and returns a string with either dark or light\n */\nfunction getModeFromSystem() {\n  if (window && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n    return 'dark';\n  }\n  return 'light';\n}\n\n/**\n * Reads the last saved mode from localStorage\n */\nfunction getModeFromLocalStore(storageId = STORAGE_ID_DEFAULT) {\n  try {\n    return localStorage.getItem(storageId);\n  } catch {\n    return null;\n  }\n}\n\n/**\n *\n * @param {string} mode Name of mode\n * @param {string} storageId ID for localStorage\n *\n * Saves to localStorage\n */\nfunction saveToStore(mode, storageId = STORAGE_ID_DEFAULT) {\n  try {\n    return localStorage.setItem(storageId, mode);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given a mode name, adds a mode-specific CSS class to <body>\n * And inserts a block of CSS into #st-mode-styleblock to set\n * values for the design tokens\n * @param {string} modeParam The mode name to apply styles for\n */\nconst updateWindowStyles = modeParam => {\n  const modeName = modeParam;\n  const modeDisplayedName = modeParam === 'auto' ? getModeFromSystem() : modeParam;\n\n  // apply modes class list to body\n  const body = document.querySelector('body');\n  body.classList.toString().split(' ').forEach(className => {\n    if (modeRegex.test(className)) body.classList.remove(className);\n  });\n  if (body.className.indexOf('st-mode') === -1) {\n    body.classList.add('st-mode');\n  }\n  const updatedThemeName = `st-mode--${modeDisplayedName}`;\n  body.classList.add(updatedThemeName);\n  const modeStyleBlock = document.getElementById('st-mode-styleblock');\n  if (!modeStyleBlock) {\n    document.head.insertAdjacentHTML('beforeend', `<style id=\"st-mode-styleblock\">${modeStyles[modeName]}</style>`);\n  } else {\n    modeStyleBlock.innerText = modeStyles[modeName];\n  }\n};\n\n/**\n * custom hook for uncontrolled version of Mode\n * for use in ThemeProvider\n * this allows users to set a starting mode with \"defaultMode\"\n * but any subsequent changes to that prop are ignored\n * in favor of whatever is in the internal state\n */\nfunction useMode({\n  defaultMode = 'auto',\n  storageId,\n  getModeFromStore,\n  setModeToStore\n} = {}) {\n  const [modeSetting, setModeSetting] = useState();\n  const [modeDisplayed, setmodeDisplayed] = useState();\n  const refModeSetting = useRef(modeSetting); // to prevent stale state in closure for userEffect\n\n  useEffect(() => {\n    refModeSetting.current = modeSetting;\n  });\n\n  // for handling initial load and setting mode\n  // if user has previously selected a mode and it's in localstore\n  // then defer to that\n  // otherwise use defaultMode\n  // if defaultMode is auto, then detect from system\n  // write all these to state and localstore\n  /* eslint-disable react-hooks/exhaustive-deps */\n  useEffect(() => {\n    let finalmode = '';\n    let modeToDisplay = '';\n    const modeFromStore = getModeFromStore && getModeFromStore() || getModeFromLocalStore(storageId);\n    // console.log(`mode from store ${storageId} is ${modeFromStore}`);\n\n    // if user has selected light or dark\n    if (modeFromStore && modeFromStore !== 'auto') {\n      finalmode = modeFromStore;\n      modeToDisplay = modeFromStore;\n    } else if (modeFromStore === 'auto' || !modeFromStore && defaultMode === 'auto') {\n      // if user has selected auto, or user hasn't selected anything and defaultMode is auto\n      finalmode = modeFromStore || defaultMode;\n      modeToDisplay = getModeFromSystem();\n    } else {\n      // user hasn't selected anything, and defaultMode is not auto\n      finalmode = defaultMode;\n      modeToDisplay = defaultMode;\n    }\n    updateWindowStyles(modeToDisplay);\n    if (setModeToStore) {\n      setModeToStore(finalmode);\n    } else {\n      saveToStore(finalmode, storageId);\n    }\n    setModeSetting(finalmode);\n    setmodeDisplayed(modeToDisplay);\n  }, []);\n  /* eslint-enable react-hooks/exhaustive-deps */\n\n  const updateModeAndWindow = useCallback(newmode => {\n    // console.log(`updateModeAndWindow called: updating mode to ${newmode}`);\n    const modeToDisplay = newmode === 'auto' ? getModeFromSystem() : newmode;\n    updateWindowStyles(modeToDisplay);\n    if (setModeToStore) {\n      setModeToStore(newmode);\n    } else {\n      saveToStore(newmode, storageId);\n    }\n    setModeSetting(newmode);\n    setmodeDisplayed(modeToDisplay);\n  }, [storageId, setModeToStore]);\n\n  // listen for changes to user's device mode\n  // so we can change dark/light mode when user updates their device preference\n  useEffect(() => {\n    function updateOnEventChange(event) {\n      // console.log(`detected event change ${refModeSetting.current}`);\n      if (refModeSetting.current === 'auto') {\n        const newmode = event.matches ? 'dark' : 'light';\n        updateWindowStyles(newmode);\n        setmodeDisplayed(newmode);\n        // console.log(`new mode is ${newmode}`);\n      }\n    }\n\n    // older versions of iOS don't support matchMedia.addEventListener\n    // once iOS 15 lands, go back to addEventListener('change', callback)\n    // console.log('setting event listener for dark mode');\n    window.matchMedia('(prefers-color-scheme: dark)').addListener(updateOnEventChange);\n    return () => window.matchMedia('(prefers-color-scheme: dark)').removeListener(updateOnEventChange);\n  }, []);\n  function toggleMode() {\n    // toggle modeSetting, can't be used when in auto\n    if (modeSetting !== 'auto') {\n      // console.log(`toggle mode from ${mode}`);\n      updateModeAndWindow(modeSetting === 'light' ? 'dark' : 'light');\n    }\n  }\n  return {\n    modeSetting,\n    modeDisplayed,\n    updateMode: updateModeAndWindow,\n    updateWindowStyles,\n    toggleMode\n  };\n}\nconst useModeDocs = () => /*#__PURE__*/React.createElement(\"div\", null, \"placeholder for storybook\");\nuseModeDocs.propTypes = {\n  /** The current user setting for the color mode. */\n  mode: PropTypes.oneOf(['auto', 'light', 'dark']).isRequired,\n  /** The color mode that is being displayed based on the user setting. */\n  modeDisplayed: PropTypes.oneOf(['light', 'dark']).isRequired,\n  /** Updates the user setting to this specific modeSetting, and also updates the data store. */\n  updateMode: PropTypes.func.isRequired,\n  /** Toggles the user setting for the mode. Only works if current setting is not `auto`. */\n  toggleMode: PropTypes.func.isRequired,\n  /** Updates appearance of color mode without updating the data store. */\n  updateWindowStyles: PropTypes.func.isRequired\n};\nexport { useMode as default, modeStyles, updateWindowStyles, useModeDocs };","map":{"version":3,"names":["React","useState","useRef","useEffect","useCallback","PropTypes","theme","modeDark","STORAGE_ID_DEFAULT","modeStyles","light","dark","modeRegex","getModeFromSystem","window","matchMedia","matches","getModeFromLocalStore","storageId","localStorage","getItem","saveToStore","mode","setItem","updateWindowStyles","modeParam","modeName","modeDisplayedName","body","document","querySelector","classList","toString","split","forEach","className","test","remove","indexOf","add","updatedThemeName","modeStyleBlock","getElementById","head","insertAdjacentHTML","innerText","useMode","defaultMode","getModeFromStore","setModeToStore","modeSetting","setModeSetting","modeDisplayed","setmodeDisplayed","refModeSetting","current","finalmode","modeToDisplay","modeFromStore","updateModeAndWindow","newmode","updateOnEventChange","event","addListener","removeListener","toggleMode","updateMode","useModeDocs","createElement","propTypes","oneOf","isRequired","func","default"],"sources":["/Users/mike/node_modules/@screentone/core/es/useMode.js"],"sourcesContent":["import React, { useState, useRef, useEffect, useCallback } from 'react';\nimport PropTypes from 'prop-types';\n\nconst theme = `:root{--st-border-color:#636e72;--st-btn-secondary-color:#7977e1;--st-btn-secondary-color-hover:#ffffff;--st-btn-secondary-bg:#000000;--st-btn-secondary-bg-hover:#9a99e8;--st-btn-secondary-bg-active:#7977e1;--st-btn-gray-color:#f5f7f8;--st-btn-gray-color-hover:#ffffff;--st-btn-gray-bg:transparent;--st-btn-gray-bg-hover:#b2bec3;--st-btn-gray-bg-active:#636e72;--st-btn-asphalt-color:#f5f7f8;--st-btn-asphalt-bg:transparent;--st-btn-asphalt-bg-hover:#2d3436;--st-btn-asphalt-bg-active:#1e2224;--st-page-bg:#000000;--st-content-bg:#1e2224;--st-content-bg-hover:#343382;--st-content-bg-active:#232257;--st-text-color-ink:#f5f7f8;--st-text-color-blurple:#9a99e8;--st-text-color-asphalt:#f5f7f8;--st-text-color-lava:#ef8e7d;--st-text-color-emerald:#97e28f;--st-text-color-white:#000000;--st-text-color:#f5f7f8;--st-text-color-support:#f5f7f8;--st-text-color-accent:#9a99e8;--st-nav-color:#ffffff;--st-nav-color-hover:#bcbbf0;--st-nav-bg:#ffffff;--st-nav-bg-hover:#343382;--st-nav-bg-active:#232257;--st-alert-warning-color:#fef3d9;--st-alert-warning-color-inverse:#957628;--st-alert-blurple-color:#ddddf7;--st-alert-blurple-color-inverse:#343382;--st-alert-gray-color:#dfe6e9;--st-alert-gray-color-inverse:#2d3436;--st-alert-error-color:#fad9d4;--st-alert-error-color-inverse:#892817;--st-alert-success-color:#dcf5da;--st-alert-success-color-inverse:#317c29;--st-token-blurple-color:#ddddf7;--st-token-blurple-bg:#5755d9;--st-token-gray-color:#dfe6e9;--st-token-gray-bg:#636e72;--st-token-rose-color:#33111d;--st-token-rose-bg:#ff77a8;--st-token-lava-color:#2e0d08;--st-token-lava-bg:#e96851;--st-token-tangerine-color:#311d0e;--st-token-tangerine-bg:#f8a66c;--st-token-sunshine-color:#32270d;--st-token-sunshine-bg:#f9d069;--st-token-emerald-color:#10290e;--st-token-emerald-bg:#97e28f;--st-token-ice-color:#0d2a33;--st-token-ice-bg:#40d0ff;--st-input-bg:#000000;--st-input-bg-disabled:#2d3436;--st-input-bg-error:#2e0d08;--st-input-handle-color:#ddddf7;--st-input-track-color:#000000;--st-input-track-color-error:#2e0d08;--st-input-icon-color:#636e72;}`;\nvar modeDark = theme;\n\n// default localstorage ID\nconst STORAGE_ID_DEFAULT = 'st-mode';\nconst modeStyles = {\n  light: '',\n  dark: modeDark\n};\nconst modeRegex = /^st-mode--[a-zA-Z]*$/;\n\n/**\n * Detects the system color mode by reading prefers-color-scheme\n * and returns a string with either dark or light\n */\nfunction getModeFromSystem() {\n  if (window && window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {\n    return 'dark';\n  }\n  return 'light';\n}\n\n/**\n * Reads the last saved mode from localStorage\n */\nfunction getModeFromLocalStore(storageId = STORAGE_ID_DEFAULT) {\n  try {\n    return localStorage.getItem(storageId);\n  } catch {\n    return null;\n  }\n}\n\n/**\n *\n * @param {string} mode Name of mode\n * @param {string} storageId ID for localStorage\n *\n * Saves to localStorage\n */\nfunction saveToStore(mode, storageId = STORAGE_ID_DEFAULT) {\n  try {\n    return localStorage.setItem(storageId, mode);\n  } catch {\n    return null;\n  }\n}\n\n/**\n * Given a mode name, adds a mode-specific CSS class to <body>\n * And inserts a block of CSS into #st-mode-styleblock to set\n * values for the design tokens\n * @param {string} modeParam The mode name to apply styles for\n */\nconst updateWindowStyles = modeParam => {\n  const modeName = modeParam;\n  const modeDisplayedName = modeParam === 'auto' ? getModeFromSystem() : modeParam;\n\n  // apply modes class list to body\n  const body = document.querySelector('body');\n  body.classList.toString().split(' ').forEach(className => {\n    if (modeRegex.test(className)) body.classList.remove(className);\n  });\n  if (body.className.indexOf('st-mode') === -1) {\n    body.classList.add('st-mode');\n  }\n  const updatedThemeName = `st-mode--${modeDisplayedName}`;\n  body.classList.add(updatedThemeName);\n  const modeStyleBlock = document.getElementById('st-mode-styleblock');\n  if (!modeStyleBlock) {\n    document.head.insertAdjacentHTML('beforeend', `<style id=\"st-mode-styleblock\">${modeStyles[modeName]}</style>`);\n  } else {\n    modeStyleBlock.innerText = modeStyles[modeName];\n  }\n};\n\n/**\n * custom hook for uncontrolled version of Mode\n * for use in ThemeProvider\n * this allows users to set a starting mode with \"defaultMode\"\n * but any subsequent changes to that prop are ignored\n * in favor of whatever is in the internal state\n */\nfunction useMode({\n  defaultMode = 'auto',\n  storageId,\n  getModeFromStore,\n  setModeToStore\n} = {}) {\n  const [modeSetting, setModeSetting] = useState();\n  const [modeDisplayed, setmodeDisplayed] = useState();\n  const refModeSetting = useRef(modeSetting); // to prevent stale state in closure for userEffect\n\n  useEffect(() => {\n    refModeSetting.current = modeSetting;\n  });\n\n  // for handling initial load and setting mode\n  // if user has previously selected a mode and it's in localstore\n  // then defer to that\n  // otherwise use defaultMode\n  // if defaultMode is auto, then detect from system\n  // write all these to state and localstore\n  /* eslint-disable react-hooks/exhaustive-deps */\n  useEffect(() => {\n    let finalmode = '';\n    let modeToDisplay = '';\n    const modeFromStore = getModeFromStore && getModeFromStore() || getModeFromLocalStore(storageId);\n    // console.log(`mode from store ${storageId} is ${modeFromStore}`);\n\n    // if user has selected light or dark\n    if (modeFromStore && modeFromStore !== 'auto') {\n      finalmode = modeFromStore;\n      modeToDisplay = modeFromStore;\n    } else if (modeFromStore === 'auto' || !modeFromStore && defaultMode === 'auto') {\n      // if user has selected auto, or user hasn't selected anything and defaultMode is auto\n      finalmode = modeFromStore || defaultMode;\n      modeToDisplay = getModeFromSystem();\n    } else {\n      // user hasn't selected anything, and defaultMode is not auto\n      finalmode = defaultMode;\n      modeToDisplay = defaultMode;\n    }\n    updateWindowStyles(modeToDisplay);\n    if (setModeToStore) {\n      setModeToStore(finalmode);\n    } else {\n      saveToStore(finalmode, storageId);\n    }\n    setModeSetting(finalmode);\n    setmodeDisplayed(modeToDisplay);\n  }, []);\n  /* eslint-enable react-hooks/exhaustive-deps */\n\n  const updateModeAndWindow = useCallback(newmode => {\n    // console.log(`updateModeAndWindow called: updating mode to ${newmode}`);\n    const modeToDisplay = newmode === 'auto' ? getModeFromSystem() : newmode;\n    updateWindowStyles(modeToDisplay);\n    if (setModeToStore) {\n      setModeToStore(newmode);\n    } else {\n      saveToStore(newmode, storageId);\n    }\n    setModeSetting(newmode);\n    setmodeDisplayed(modeToDisplay);\n  }, [storageId, setModeToStore]);\n\n  // listen for changes to user's device mode\n  // so we can change dark/light mode when user updates their device preference\n  useEffect(() => {\n    function updateOnEventChange(event) {\n      // console.log(`detected event change ${refModeSetting.current}`);\n      if (refModeSetting.current === 'auto') {\n        const newmode = event.matches ? 'dark' : 'light';\n        updateWindowStyles(newmode);\n        setmodeDisplayed(newmode);\n        // console.log(`new mode is ${newmode}`);\n      }\n    }\n\n    // older versions of iOS don't support matchMedia.addEventListener\n    // once iOS 15 lands, go back to addEventListener('change', callback)\n    // console.log('setting event listener for dark mode');\n    window.matchMedia('(prefers-color-scheme: dark)').addListener(updateOnEventChange);\n    return () => window.matchMedia('(prefers-color-scheme: dark)').removeListener(updateOnEventChange);\n  }, []);\n  function toggleMode() {\n    // toggle modeSetting, can't be used when in auto\n    if (modeSetting !== 'auto') {\n      // console.log(`toggle mode from ${mode}`);\n      updateModeAndWindow(modeSetting === 'light' ? 'dark' : 'light');\n    }\n  }\n  return {\n    modeSetting,\n    modeDisplayed,\n    updateMode: updateModeAndWindow,\n    updateWindowStyles,\n    toggleMode\n  };\n}\nconst useModeDocs = () => /*#__PURE__*/React.createElement(\"div\", null, \"placeholder for storybook\");\nuseModeDocs.propTypes = {\n  /** The current user setting for the color mode. */\n  mode: PropTypes.oneOf(['auto', 'light', 'dark']).isRequired,\n  /** The color mode that is being displayed based on the user setting. */\n  modeDisplayed: PropTypes.oneOf(['light', 'dark']).isRequired,\n  /** Updates the user setting to this specific modeSetting, and also updates the data store. */\n  updateMode: PropTypes.func.isRequired,\n  /** Toggles the user setting for the mode. Only works if current setting is not `auto`. */\n  toggleMode: PropTypes.func.isRequired,\n  /** Updates appearance of color mode without updating the data store. */\n  updateWindowStyles: PropTypes.func.isRequired\n};\n\nexport { useMode as default, modeStyles, updateWindowStyles, useModeDocs };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}